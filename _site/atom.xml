<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Welcome to the bundle</title>
 <link href="http://welcometothebundle.com/atom.xml" rel="self"/>
 <link href="http://welcometothebundle.com"/>
 <updated>2013-11-17T19:17:18+01:00</updated>
 <id>http://welcometothebundle.com</id>
 <author>
   <name>liuggio</name>
   <email>liuggio@liuggio</email>
 </author>

 
 <entry>
   <title>part2 - Web API REST with Symfony2: the best way - The POST method</title>
   <link href="http://welcometothebundle.com/web-api-rest-with-symfony2-the-best-way-the-post-method"/>
   <updated>2013-11-16T13:00:00+01:00</updated>
   <id>http://welcometothebundle.com/web-api-rest-with-symfony2-the-best-way-the-post-method</id>
   <content type="html">&lt;h3 id='part_2__the_'&gt;Part 2 - the &lt;code&gt;POST&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;In the &amp;#8217;&lt;a href='http://welcometothebundle.com/symfony2-rest-api-the-best-2013-way/'&gt;Symfony2 REST part 1&lt;/a&gt;&amp;#8217; we created the application, the bundle, we talked about the &lt;code&gt;GET&lt;/code&gt; method, we also talked about the importance of the Interfaces, the content negotiation, and we gave an example of dumb controllers and brain services.&lt;/p&gt;

&lt;p&gt;In this blog post we are going to create a new &lt;code&gt;Page&lt;/code&gt; via REST API: the form is the protagonist of this article.&lt;/p&gt;

&lt;h2 id='the_github_repository'&gt;The github repository&lt;/h2&gt;

&lt;p&gt;There&amp;#8217;s a repository at &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/'&gt;liuggio/symfony2-rest-api-the-best-2013-way&lt;/a&gt; you could see the working code using the tag &lt;code&gt;part2&lt;/code&gt; with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php composer.phar create-project liuggio/symfony2-rest-api-the-best-2013-way blog-rest-symfony2 -sdev
cd blog-rest-symfony2
git checkout -f part2
bin/phpunit -c app&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the tags for the demo project are at &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/tags'&gt;tags&lt;/a&gt;, and also you could compare the first 2 articles with &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/compare/part1...part2'&gt;compare/part1&amp;#8230;part2&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id='the_creation'&gt;The creation&lt;/h2&gt;

&lt;p&gt;We need a REST API that allows the creation of a Page.&lt;/p&gt;

&lt;h3 id='the_verbs'&gt;The verbs&lt;/h3&gt;

&lt;p&gt;Since you want to follow the REST methodology, you should create a web interface, which will make use of the HTTP verbs that are available.&lt;/p&gt;

&lt;p&gt;The good practices suggests to use &lt;strong&gt;nouns&lt;/strong&gt; not verbs, the verbs should used into the header for the HTTP request (this is not really always true we&amp;#8217;ll see in the third part).&lt;/p&gt;

&lt;p&gt;The convention also imposes to use plurals nouns, &lt;code&gt;pages&lt;/code&gt; instead page, is simpler and coherent.&lt;/p&gt;

&lt;p&gt;The following table shoo&lt;/p&gt;
&lt;table class='table'&gt;
&lt;thead&gt;
&lt;tr&gt;
    &lt;th&gt;Resource&lt;/th&gt;
    &lt;th&gt;GET&lt;/th&gt;
    &lt;th&gt;POST&lt;/th&gt;
    &lt;th&gt;PUT&lt;/th&gt;
    &lt;th&gt;PATCH&lt;/th&gt;
    &lt;th&gt;DELETE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;b&gt;pages&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;List of Pages&lt;/td&gt;
    &lt;td&gt;Create a new Page&lt;/td&gt;
    &lt;td&gt;-&lt;/td&gt;
    &lt;td&gt;-&lt;/td&gt;
    &lt;td&gt;[Delete all the pages]*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;b&gt;pages/{id}&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;Show pages/10&lt;/td&gt;
    &lt;td&gt;-&lt;/td&gt;
    &lt;td&gt;Update a specific page &lt;br /&gt;[and create if not exists]*&lt;/td&gt;
    &lt;td&gt;Partial update a specific page&lt;/td&gt;
    &lt;td&gt;Delete a specific page&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The &lt;code&gt;POST&lt;/code&gt; should create a new resource, the &lt;code&gt;PUT&lt;/code&gt; should modify an entity.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;PUT&lt;/code&gt; should also create the resource if it not exists, please see the definition of &lt;code&gt;safe&lt;/code&gt; and &lt;code&gt;idempotent&lt;/code&gt;. But in some web API the objective of the PUT is only to update a given resource, because is just simpler separate the creation with &lt;code&gt;POST&lt;/code&gt; and the update with &lt;code&gt;PUT&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id='the_actions'&gt;The actions&lt;/h3&gt;

&lt;p&gt;The table below, describes the name of the actions, on the head of the table the HTTP verbs.&lt;/p&gt;
&lt;table class='table'&gt;
&lt;thead&gt;
&lt;tr&gt;
    &lt;th&gt;Resource&lt;/th&gt;
    &lt;th&gt;GET&lt;/th&gt;
    &lt;th&gt;POST&lt;/th&gt;
    &lt;th&gt;PUT&lt;/th&gt;
    &lt;th&gt;PATCH&lt;/th&gt;
    &lt;th&gt;DELETE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;b&gt;pages&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;List of Pages
&lt;br /&gt;
    getPagesAction()
    &lt;/td&gt;
    &lt;td&gt;Create a new Page&lt;br /&gt;
    postPagesAction()
    &lt;/td&gt;
    &lt;td&gt;-&lt;/td&gt;
    &lt;td&gt;-&lt;/td&gt;
    &lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;&lt;b&gt;pages/{id}&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;Show
&lt;br /&gt;
    getPageAction($id)&lt;/td&gt;
    &lt;td&gt;-&lt;/td&gt;
    &lt;td&gt;Update
&lt;br /&gt;
    putPageAction($id) &lt;/td&gt;
    &lt;td&gt;Partial update
&lt;br /&gt;
    patchPageAction($id)&lt;/td&gt;
    &lt;td&gt;Delete
&lt;br /&gt;deletePageAction($id)
    &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;So just creating the action properly we will have automatically configured the routes, with the proper HTTP verbs.&lt;/p&gt;

&lt;p&gt;More info at &lt;a href='https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/5-automatic-route-generation_single-restful-controller.md#rest-actions'&gt;rest-action fosRestBundle&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id='post'&gt;POST&lt;/h3&gt;

&lt;p&gt;The story: calling the resource &lt;code&gt;/api/v1/pages.json&lt;/code&gt; with POST method, and giving the whole serialized content of a &lt;code&gt;Page&lt;/code&gt; entity, the response should have the status code &lt;code&gt;201&lt;/code&gt;, and should be a json response.&lt;/p&gt;

&lt;p&gt;We could easily write this story into a functional test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src\Acme\BlogBundle\Tests\Controller\PageControllerTest
public function testJsonPostPageAction()
{
    $this-&amp;gt;client = static::createClient();
    $this-&amp;gt;client-&amp;gt;request(
        &amp;#39;POST&amp;#39;, 
        &amp;#39;/api/v1/pages.json&amp;#39;,  
        array(),
        array(),
        array(&amp;#39;CONTENT_TYPE&amp;#39; =&amp;gt; &amp;#39;application/json&amp;#39;),
        &amp;#39;{&amp;quot;title&amp;quot;:&amp;quot;title1&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;body1&amp;quot;}&amp;#39;
    );

    $this-&amp;gt;assertJsonResponse($this-&amp;gt;client-&amp;gt;getResponse(), 201, false);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and there is another story:&lt;/p&gt;

&lt;p&gt;calling the resource &lt;code&gt;/api/v1/pages.json&lt;/code&gt; with the POST method, and giving a not correct serialized content of the &lt;code&gt;Page&lt;/code&gt; entity, the response should have the status code &lt;code&gt;400&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testJsonPostPageActionShouldReturn400WithBadParameters()
{
    $this-&amp;gt;client = static::createClient();
    $this-&amp;gt;client-&amp;gt;request(
        &amp;#39;POST&amp;#39;,
        &amp;#39;/api/v1/pages.json&amp;#39;,
        array(),
        array(),
        array(&amp;#39;CONTENT_TYPE&amp;#39; =&amp;gt; &amp;#39;application/json&amp;#39;),
        &amp;#39;{&amp;quot;ninja&amp;quot;:&amp;quot;turtles&amp;quot;}&amp;#39;
    );

    $this-&amp;gt;assertJsonResponse($this-&amp;gt;client-&amp;gt;getResponse(), 400, false);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course the tests are red, we had to add the &lt;code&gt;post&lt;/code&gt; function in &lt;code&gt;PageHandler&lt;/code&gt; then the &lt;code&gt;postPageAction&lt;/code&gt; in the Controller.&lt;/p&gt;

&lt;p&gt;We are going to create a &lt;code&gt;post&lt;/code&gt; function that takes the parameters (as an array) containing all the fields of the entity &lt;code&gt;Page&lt;/code&gt;, the form is responsible to validate and hydrate the new &lt;code&gt;Page&lt;/code&gt; object, then this object is persisted to the Object Manager.&lt;/p&gt;

&lt;h2 id='the_validation'&gt;The validation&lt;/h2&gt;

&lt;p&gt;We have to add a validation layer that will be invisible because the form will perform it automatically:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# src/Acme/BlogBundle/Resources/config/validation.yml
Acme\BlogBundle\Entity\Page:
    properties:
        title:
            - NotBlank: ~
            - NotNull: ~
            - Length:
                min: 2
                max: 50
                minMessage: &amp;quot;Your title must be at least  characters length&amp;quot;
                maxMessage: &amp;quot;Your title name cannot be longer than  characters length&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='the_pagehandlerpost'&gt;The PageHandler::post&lt;/h2&gt;

&lt;p&gt;In the first article we created a service called &lt;code&gt;PageHandler&lt;/code&gt;, its objective is to respect the &lt;code&gt;PageHandlerInterface&lt;/code&gt;, serving the &lt;code&gt;Page&lt;/code&gt; entity with &lt;code&gt;get(id)&lt;/code&gt; and &lt;code&gt;post()&lt;/code&gt;: it could read and write a &lt;code&gt;Page&lt;/code&gt; resource.&lt;/p&gt;

&lt;p&gt;The first step should be create a test that respects the behavior that we want for the post.&lt;/p&gt;

&lt;p&gt;Given parameters containing properties of the &lt;code&gt;Page&lt;/code&gt; like &lt;code&gt;array(&amp;#39;title&amp;#39;=&amp;gt;&amp;#39;title&amp;#39;)&lt;/code&gt; the function should return an already persisted object respecting the interface &lt;code&gt;PageInterface&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id='the_post'&gt;The post&lt;/h3&gt;

&lt;p&gt;We are now going to create a function that look like even in the name to the controller&amp;#8217;s function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src/Acme/BlogBundle/Handler/PageHandler.php
/**
 * Create a new Page.
 *
 * @param array $parameters
 *
 * @return PageInterface
 */
public function post(array $parameters)
{
    $page = $this-&amp;gt;createPage(); // factory method create an empty Page

    // Process form does all the magic, validate and hydrate the Page Object.
    return $this-&amp;gt;processForm($page, $parameters, &amp;#39;POST&amp;#39;);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='the_form_factory'&gt;The form factory&lt;/h3&gt;

&lt;p&gt;In order to use the form we need the &lt;code&gt;form.factory&lt;/code&gt; injected into the service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src\Acme\BlogBundle\Handler\PageHandler.php
use Symfony\Component\Form\FormFactoryInterface;
// ...
class PageHandler implements PageHandlerInterface
// ...
private $formFactory;
// ...
public function __construct(ObjectManager $om, $entityClass, FormFactoryInterface $formFactory)
{
    $this-&amp;gt;om = $om;
    $this-&amp;gt;entityClass = $entityClass;
    $this-&amp;gt;repository = $this-&amp;gt;om-&amp;gt;getRepository($this-&amp;gt;entityClass);
    $this-&amp;gt;formFactory = $formFactory;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then we have to add a new argument into the page handler service at &lt;code&gt;/src/Acme/BlogBundle/Resources/config/services.xml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; ?&amp;gt;
&amp;lt;services&amp;gt;
    &amp;lt;service id=&amp;quot;acme_blog.page.handler&amp;quot; class=&amp;quot;%acme_blog.page.handler.class%&amp;quot;&amp;gt;
        &amp;lt;argument type=&amp;quot;service&amp;quot; id=&amp;quot;doctrine.orm.entity_manager&amp;quot; /&amp;gt;
        &amp;lt;argument&amp;gt;%acme_blog.page.class%&amp;lt;/argument&amp;gt;
        &amp;lt;argument type=&amp;quot;service&amp;quot; id=&amp;quot;form.factory&amp;quot;&amp;gt;&amp;lt;/argument&amp;gt;
    &amp;lt;/service&amp;gt;
&amp;lt;/services&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='the_processform'&gt;The processForm&lt;/h3&gt;

&lt;p&gt;It&amp;#8217;s time to back to &lt;code&gt;\Acme\BlogBundle\Handler\PageHandler&lt;/code&gt; and create the &lt;code&gt;processForm&lt;/code&gt; function, the hearth of the write functions.&lt;/p&gt;

&lt;p&gt;You have surely already used &lt;a href='http://api.symfony.com/2.3/Symfony/Component/Form/FormInterface.html'&gt;form-&amp;gt;handleRequest($request)&lt;/a&gt;, but in this case we don&amp;#8217;t have the Request but only the values ​​ in an array, so instead of &lt;code&gt;handleRequest&lt;/code&gt;, we are going to &lt;code&gt;submit&lt;/code&gt; the form.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Processes the form.
 *
 * @param PageInterface $page
 * @param array         $parameters
 * @param String        $method
 *
 * @return PageInterface
 *
 * @throws Acme\BlogBundle\Exception\InvalidFormException
 */
private function processForm(PageInterface $page, array $parameters, $method = &amp;quot;PUT&amp;quot;)
{
    $form = $this-&amp;gt;formFactory-&amp;gt;create(new PageType(), $page, array(&amp;#39;method&amp;#39; =&amp;gt; $method));
    $form-&amp;gt;submit($parameters, &amp;#39;PATCH&amp;#39; !== $method);
    if (!$form-&amp;gt;isValid()) {
        throw new InvalidFormException(&amp;#39;Invalid submitted data&amp;#39;, $form);
    }
    $page = $form-&amp;gt;getData(); // get the hydrated Page object
    $this-&amp;gt;om-&amp;gt;persist($page);// persistence layer
    $this-&amp;gt;om-&amp;gt;flush($page);

    return $page;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function returns an object of &lt;code&gt;PageInterface&lt;/code&gt; type, but if the parameters are not valid it throws an &lt;code&gt;InvalidFormException&lt;/code&gt; that will be handled and caught by the controller.&lt;/p&gt;

&lt;p&gt;The test class is at &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/blob/part2/src/Acme/BlogBundle/Tests/Handler/PageHandlerTest.php/'&gt;part2-src/Acme/BlogBundle/Tests/Handler/PageHandlerTest.php&lt;/a&gt;&lt;/p&gt;

&lt;h3 id='why_dont_use_the_request'&gt;Why don&amp;#8217;t use the request?&lt;/h3&gt;

&lt;p&gt;The real question is: do we really need the request here?&lt;/p&gt;

&lt;p&gt;The answer is &lt;strong&gt;no&lt;/strong&gt;, the main responsibility of &lt;code&gt;PageHandler&lt;/code&gt; class is to &lt;code&gt;handle&lt;/code&gt; (creating, editing, showing) the &lt;code&gt;Page&lt;/code&gt; entity, given some parameters, it doesn&amp;#8217;t care about Request.&lt;/p&gt;

&lt;p&gt;In this way you could use &lt;code&gt;PageHandler&lt;/code&gt; from container services, without injecting or faking the Request.&lt;/p&gt;

&lt;p&gt;In the end of this series of articles you will have an application that serves REST API,&lt;/p&gt;

&lt;p&gt;but the PageHandler is itself an API, usable by services of your application via service container.&lt;/p&gt;

&lt;h2 id='the_post_and_the_controller'&gt;The POST and the Controller&lt;/h2&gt;

&lt;h3 id='the_function'&gt;The function&lt;/h3&gt;

&lt;p&gt;The postPageAction is simple, all the domain logic is demanded to the &lt;code&gt;PageHandler&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Create a Page from the submitted data.
 *
 * @ApiDoc(
 *   resource = true,
 *   description = &amp;quot;Creates a new page from the submitted data.&amp;quot;,
 *   input = &amp;quot;Acme\BlogBundle\Form\PageType&amp;quot;,
 *   statusCodes = {
 *     200 = &amp;quot;Returned when successful&amp;quot;,
 *     400 = &amp;quot;Returned when the form has errors&amp;quot;
 *   }
 * )
 *
 * @Annotations\View(
 *  template = &amp;quot;AcmeBlogBundle:Page:newPage.html.twig&amp;quot;,
 *  statusCode = Codes::HTTP_BAD_REQUEST
 * )
 *
 * @return FormTypeInterface|RouteRedirectView
 */
public function postPageAction()
{
    try {
    	// Hey handler create a page for me.
        $newPage = $this-&amp;gt;container-&amp;gt;get(&amp;#39;acme_blog.page.handler&amp;#39;)-&amp;gt;post(
                // this is the body of the request
                $this-&amp;gt;container-&amp;gt;get(&amp;#39;request&amp;#39;)-&amp;gt;request-&amp;gt;all()
        );

        $routeOptions = array(
            &amp;#39;id&amp;#39; =&amp;gt; $newPage-&amp;gt;getId(),
            &amp;#39;_format&amp;#39; =&amp;gt; $this-&amp;gt;container-&amp;gt;get(&amp;#39;request&amp;#39;)-&amp;gt;get(&amp;#39;_format&amp;#39;)
        );

        // return HTTP_CREATED, and add location header
        return $this-&amp;gt;routeRedirectView(&amp;#39;api_1_get_page&amp;#39;, $routeOptions, Codes::HTTP_CREATED);

    } catch (InvalidFormException $exception) {

        return $this-&amp;gt;view(array(&amp;#39;errors&amp;#39; =&amp;gt; $exception-&amp;gt;getForm()), Codes::HTTP_BAD_REQUEST);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='the_location'&gt;The location&lt;/h3&gt;

&lt;p&gt;A new page is created by the &lt;code&gt;PageHandler&lt;/code&gt;, then the helper &lt;code&gt;routeRedirectView&lt;/code&gt; adds to the http header the location: &lt;code&gt;http://localhost:8000/api/v1/pages/47.json&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id='the_template'&gt;The template&lt;/h3&gt;

&lt;p&gt;Remember to create the template newPage.html.twig something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/src/Acme/BlogBundle/Resources/views/Page/newPage.html.twig
&amp;lt;h1&amp;gt;Page Form&amp;lt;/h1&amp;gt;
&amp;lt;form action=&amp;quot;{ { url(&amp;#39;api_1_post_page&amp;#39;) } }&amp;quot; method=&amp;quot;POST&amp;quot; { { form_enctype(form) } }&amp;gt;
    { { form_widget(form) } }
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;submit&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='the_api'&gt;The API&lt;/h3&gt;

&lt;p&gt;Maybe it has gone unnoticed but the inputs to the post is not the &lt;code&gt;Page&lt;/code&gt; object but a form type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* @ApiDoc(
*   ...
*   input = &amp;quot;Acme\BlogBundle\Form\PageType&amp;quot;,
*   ...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;#8217;d see how much the form is important in our API application.&lt;/p&gt;

&lt;h3 id='the_name_of_the_form_type'&gt;The name of the Form type&lt;/h3&gt;

&lt;p&gt;One thing that seems very obscure in the eyes of those doing the rest with the form is the &lt;code&gt;getName&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;in all the examples above we sent all the data with an empty &lt;code&gt;PageType::name&lt;/code&gt; but if we&amp;#8217;d change to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src/Acme/BlogBundle/Form/PageType.php
/**
 * @return string
 */
public function getName()
{
    return &amp;#39;page&amp;#39;;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The data should be sent with a different syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X POST -d &amp;#39;{&amp;quot;page&amp;quot;:{&amp;quot;title&amp;quot;:&amp;quot;title1&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;body1&amp;quot;}}&amp;#39; http://localhost:8000/api/v1/pages.json --header &amp;quot;Content-Type:application/json&amp;quot; -v&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the controller should look something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function postPageAction()
{
    try {
        $form = new PageType();
        $newPage = $this-&amp;gt;container-&amp;gt;get(&amp;#39;acme_blog.page.handler&amp;#39;)-&amp;gt;post(
                $this-&amp;gt;container-&amp;gt;get(&amp;#39;request&amp;#39;)-&amp;gt;request-&amp;gt;get($form-&amp;gt;getName())
        );
// ...&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='rest_is_also_for_human'&gt;Rest is (also) for human&lt;/h2&gt;

&lt;p&gt;The title &lt;code&gt;Rest is also for human&lt;/code&gt; is self explanatory and the guys at Friends Of Symfony, explained how to create adding some &lt;code&gt;conventional actions&lt;/code&gt; could increase the interaction with the REST process:&lt;/p&gt;

&lt;h3 id='conventional_actions'&gt;Conventional Actions&lt;/h3&gt;
&lt;blockquote&gt;
HATEOAS, or Hypermedia as the Engine of Application State, is an aspect of REST which allows clients to interact with the REST service with hypertext - most commonly through an HTML page. There are 3 Conventional Action routings that are supported by this bundle: 

&lt;b&gt;new&lt;/b&gt;, &lt;b&gt;edit&lt;/b&gt;, &lt;b&gt;remove&lt;/b&gt; ... from FOSREST-1
&lt;/blockquote&gt;
&lt;h3 id='people_and_rest_got_the_power'&gt;People (and REST) got the power&lt;/h3&gt;

&lt;p&gt;There are many protocols and each has its advantages and its reasons, SOAP, XML-RPC. The added value of REST is that it is not just for client API and web browser is &lt;strong&gt;for people too&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In this article we are not going to provide the glory of rest, but only some tips, in order to create clean API and clean code.&lt;/p&gt;

&lt;h3 id='the_newpage_action'&gt;The newPage action&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;new&lt;/strong&gt; - A hypermedia representation that acts as the engine to POST. Typically this is a form that allows the client to POST a new resource. Shown as PageController::newPagesAction()&lt;/p&gt;

&lt;p&gt;We are providing a REST API for &lt;code&gt;json&lt;/code&gt;, &lt;code&gt;xml&lt;/code&gt;, and &lt;code&gt;html&lt;/code&gt; formats, so a user could be able to create a correct request, we should provide also a web page to create the form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Presents the form to use to create a new page.
 *
 * @ApiDoc(
 *   resource = true,
 *   statusCodes = {
 *     200 = &amp;quot;Returned when successful&amp;quot;
 *   }
 * )
 *
 * @Annotations\View()
 *
 * @return FormTypeInterface
 */
public function newPageAction()
{
    return $this-&amp;gt;createForm(new PageType());
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Automatically a new route is added at &lt;code&gt;/api/v1/pages/new.{_format}&lt;/code&gt; you could check it with&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app/console router:debug | grep api&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Accessing to the the page with &lt;code&gt;curl -S localhost:8000/api/v1/pages/new&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;you will obtain a working html form.&lt;/p&gt;

&lt;h2 id='manually_test_the_application'&gt;Manually test the application&lt;/h2&gt;

&lt;h3 id='the_happy_path_201'&gt;The happy path 201&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;curl -X POST -d &amp;#39;{&amp;quot;title&amp;quot;:&amp;quot;title&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;body&amp;quot;}&amp;#39; http://localhost:8000/api/v1/pages.json --header &amp;quot;Content-Type:application/json&amp;quot; &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will return&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt; HTTP/1.1 201 Created
&amp;lt; Host: localhost:8000
&amp;lt; Location: http://localhost:8000/api/v1/pages/50.json
&amp;lt; Allow: POST
&amp;lt; Content-Type: application/json&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is great! HTTP Status code &lt;code&gt;201&lt;/code&gt; resource created, and location tells to the consumers where to get this resource.&lt;/p&gt;

&lt;h3 id='bad_parameters_400'&gt;Bad parameters 400&lt;/h3&gt;

&lt;p&gt;Let&amp;#8217;s try to send a bad content:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X POST -d &amp;#39;{&amp;quot;ninja&amp;quot;:&amp;quot;title&amp;quot;,&amp;quot;turtles&amp;quot;:&amp;quot;body&amp;quot;}&amp;#39; http://localhost:8000/api/v1/pages.json --header &amp;quot;Content-Type:application/json&amp;quot; -v&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Response will be &lt;code&gt;400&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt; HTTP/1.1 400 Bad Request
&amp;lt; Host: localhost:8000
&amp;lt; Content-Type: application/json
&amp;lt; 
&amp;lt; {&amp;quot;form&amp;quot;:{&amp;quot;errors&amp;quot;:[&amp;quot;This form should not contain extra fields.&amp;quot;],&amp;quot;children&amp;quot;:{&amp;quot;title&amp;quot;:[],&amp;quot;body&amp;quot;:[]}}}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='things_to_know_and_not_always_to_do'&gt;Things to know (and not always to do)&lt;/h2&gt;

&lt;p&gt;There are simple steps that could improve a little bit the project:&lt;/p&gt;

&lt;h3 id='the_nonproblem'&gt;The non-problem&lt;/h3&gt;

&lt;p&gt;Do you remember how we used the formFactory in the PageHandler?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src\Acme\BlogBundle\Handler\PageHandler::$formFactory
$form = $this-&amp;gt;formFactory-&amp;gt;create(new PageType(), $page, array(&amp;#39;method&amp;#39; =&amp;gt; $method));&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and do you remember how we created the PageType?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src/Acme/BlogBundle/Form/PageType.php
&amp;#39;data_class&amp;#39; =&amp;gt; &amp;#39;Acme\BlogBundle\Entity\Page&amp;#39;,&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We hardcoded the classes inside another class, we create an hard dependency.&lt;/p&gt;

&lt;h3 id='the_solution'&gt;The solution&lt;/h3&gt;

&lt;p&gt;we could create the PageType as service, and use the name of the service from the PageHandler.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;parameter key=&amp;quot;acme_blog.page.type.class&amp;quot;&amp;gt;Acme\BlogBundle\Form\PageType&amp;lt;/parameter&amp;gt;
&amp;lt;parameter key=&amp;quot;acme_blog.page.type.name&amp;quot;&amp;gt;&amp;lt;/parameter&amp;gt;
&amp;lt;parameter key=&amp;quot;acme_blog.page.type.alias&amp;quot;&amp;gt;leaphly_cart&amp;lt;/parameter&amp;gt;

&amp;lt;service id=&amp;quot;acme_blog.page.type&amp;quot; class=&amp;quot;Leaphly\CartBundle\Form\Type\CartFormType&amp;quot;&amp;gt;
    &amp;lt;argument&amp;gt;%acme_blog.page.type.class%&amp;lt;/argument&amp;gt;
    &amp;lt;tag name=&amp;quot;form.type&amp;quot; alias=&amp;quot;%acme_blog.page.type.alias%&amp;quot; /&amp;gt;
&amp;lt;/service&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then in the &lt;code&gt;Page handler&lt;/code&gt; do something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;formFactory-&amp;gt;createNamed ...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the code given on github &lt;strong&gt;doesn&amp;#8217;t cover&lt;/strong&gt; the form type as service.&lt;/p&gt;

&lt;h3 id='justifying_this_extra_effort'&gt;Justifying this extra effort&lt;/h3&gt;

&lt;p&gt;In few cases this could be considered an &lt;a href='http://en.wikipedia.org/wiki/Overengineering'&gt;over-engineered&lt;/a&gt; task,&lt;/p&gt;

&lt;p&gt;but when the form type needs extra powers(eg. database access) or when we want to remove all the hard-coding and explicit classes, or if we want to centralize the parameters and the classes in order to be easily changed or renamed, the form type as service could be useful.&lt;/p&gt;

&lt;h2 id='the_documentation_as_bonus'&gt;The documentation as bonus&lt;/h2&gt;

&lt;p&gt;With &lt;a href='https://github.com/nelmio/NelmioApiDocBundle'&gt;NelmioApiDocBundle&lt;/a&gt; we will have a documentation &lt;strong&gt;for free&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;adding a route:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# app/config/routing.yml
NelmioApiDocBundle:
    resource: &amp;quot;@NelmioApiDocBundle/Resources/config/routing.yml&amp;quot;
    prefix:   /api/doc&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then modifying the PostAction annotations&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @ApiDoc(
 *   resource = true,
 *   description = &amp;quot;Creates a new page from the submitted data.&amp;quot;,
 *   input = &amp;quot;Acme\BlogBundle\Form\PageType&amp;quot;,
 *   statusCodes = {
 *     200 = &amp;quot;Returned when successful&amp;quot;,
 *     400 = &amp;quot;Returned when the form has errors&amp;quot;
 *   }
 * )
 */
public function postPageAction()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And thanks to &lt;a href='https://github.com/nelmio/NelmioApiDocBundle/graphs/contributors'&gt;this guys&lt;/a&gt; you will have something like:&lt;/p&gt;

&lt;p&gt;&lt;img alt='NelmioApiDocBundle screen-shot' src='/assets/themes//readable-liuggio/img/screenshot-nelmio.png' /&gt;&lt;/p&gt;

&lt;h2 id='recap'&gt;Recap&lt;/h2&gt;

&lt;p&gt;Now we could create and read a resource via HTTP REST, using those routes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;api_1_get_page           GET    ANY    ANY  /api/v1/pages/{id}.{_format}
api_1_new_page           GET    ANY    ANY  /api/v1/pages/new.{_format}
api_1_post_page          POST   ANY    ANY  /api/v1/pages.{_format}
nelmio_api_doc_index     GET    ANY    ANY  /api/doc/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also have created another API usable via service container and the API are defined into the &lt;code&gt;PageHandlerInterface&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src/Acme/BlogBundle/Handler/PageHandlerInterface.php
interface PageHandlerInterface
{
    /**
     * Get a Page given the identifier
     *
     * @api
     *
     * @param int $id
     *
     * @return PageInterface
     */
    public function get($id);

    /**
     * Post Page, creates a new Page.
     *
     * @api
     *
     * @param array $parameters
     *
     * @return PageInterface
     */
    public function post(array $parameters);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='next'&gt;Next&lt;/h2&gt;

&lt;p&gt;In the next articles, we will describe how to delete, edit partially and totally a resource with &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, we will detail how use other important HTTP headers, we will play with &lt;code&gt;filter&lt;/code&gt; and a simple js integration.&lt;/p&gt;

&lt;h3 id='references'&gt;References&lt;/h3&gt;

&lt;p&gt;&lt;a href='http://zachholman.com/2010/03/the-human-is-a-restful-client/'&gt;ZAC-1 - Zach Holman: The Human is a RESTful Client&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='https://github.com/FriendsOfSymfony/FOSRestBundle/blob/master/Resources/doc/5-automatic-route-generation_single-restful-controller.md#conventional-actions'&gt;FOSREST-1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://symfony.com/doc/current/cookbook/form/direct_submit.html'&gt;symfony.com/doc/current/cookbook/form/direct_submit.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://symfony.com/doc/current/cookbook/form/create_custom_field_type.html'&gt;symfony.com/doc/current/cookbook/form/create_custom_field_type.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='https://github.com/nelmio/NelmioApiDocBundle'&gt;NelmioApiDocBundle&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='https://github.com/lsmith77/symfony-rest-edition/'&gt;lsmith77/symfony-rest-edition/&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Symfony2 REST API: the best way</title>
   <link href="http://welcometothebundle.com/symfony2-rest-api-the-best-2013-way"/>
   <updated>2013-11-13T13:00:00+01:00</updated>
   <id>http://welcometothebundle.com/symfony2-rest-api-the-best-2013-way</id>
   <content type="html">&lt;h3 id='part_1__the_'&gt;Part 1 - the &lt;code&gt;GET&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Here&amp;#8217;s another nice guide on how to create an API with Symfony2, this is the &lt;strong&gt;part 1&lt;/strong&gt; of a series of articles.&lt;/p&gt;

&lt;p&gt;I would like to be short and concise bringing practical examples.&lt;/p&gt;

&lt;p&gt;I would not talk about the difference between REST and RESTful &lt;a href='http://martinfowler.com/articles/richardsonMaturityModel.html'&gt;Martin Fowler Maturity Model&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The title of this series is just because I&amp;#8217;ve found a lot of great ideas from the &lt;a href='http://williamdurand.fr/2012/08/02/rest-apis-with-symfony2-the-right-way/'&gt;William Durand: rest-apis-with-symfony2-the-right-way&lt;/a&gt; blog written in 2012, so this is a revisited version, talking more about form, and services.&lt;/p&gt;

&lt;h2 id='motivation'&gt;Motivation&lt;/h2&gt;

&lt;p&gt;Writing Leaphly &lt;a href='http://leaphly.org'&gt;symfony cart rest&lt;/a&gt; we had few problems finding a tutorial or a blog post that could show us how to properly use REST and symfony2 with forms and doctrine.&lt;/p&gt;

&lt;h2 id='goal'&gt;GOAL&lt;/h2&gt;

&lt;p&gt;We are going to create an application that serves API for Page content with &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt; and &lt;code&gt;patch&lt;/code&gt;, using &lt;a href='http://www.symfony2.com'&gt;Symfony2&lt;/a&gt;, the &lt;a href='https://github.com/FriendsOfSymfony/FOSRestBundle'&gt;FOSRestBundle&lt;/a&gt;, the &lt;a href='https://github.com/nelmio/NelmioApiDocBundle'&gt;NelmioApiDocBundle&lt;/a&gt;, the &lt;a href='https://github.com/schmittjoh/JMSSerializerBundle'&gt;JSMSerializerBundle&lt;/a&gt;, and &lt;a href='http://www.doctrine-project.org'&gt;Doctrine&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The real objective is create an application that shows some best practices and rules with Symfony2 and REST:&lt;/p&gt;

&lt;h3 id='rules'&gt;Rules&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Interface as contracts.&lt;/li&gt;

&lt;li&gt;Thin Controller, Fat Service.&lt;/li&gt;

&lt;li&gt;The &lt;code&gt;Content Negotiation&lt;/code&gt; in the HTTP and REST.&lt;/li&gt;

&lt;li&gt;Form as API interface.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='the_github_repository'&gt;The github repository&lt;/h2&gt;

&lt;p&gt;There&amp;#8217;s a repository at &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/'&gt;liuggio/symfony2-rest-api-the-best-2013-way&lt;/a&gt; you could see the working code using the tag &lt;code&gt;part1&lt;/code&gt; with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php composer.phar create-project liuggio/symfony2-rest-api-the-best-2013-way blog-rest-symfony2 -sdev
cd blog-rest-symfony2
git checkout -f part1
bin/phpunit -c app&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the tags for the demo project at &lt;a href='https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/tags'&gt;tags&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='step_1a_the_application'&gt;Step 1.A The application&lt;/h2&gt;

&lt;p&gt;Create a Symfony application&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php composer.phar create-project symfony/framework-standard-edition BlogRESTAPI/
cd BlogRESTAPI
php composer.phar require &amp;quot;friendsofsymfony/rest-bundle&amp;quot; &amp;quot;@dev&amp;quot;
php composer.phar require &amp;quot;jms/serializer-bundle&amp;quot; &amp;quot;@dev&amp;quot;
php composer.phar require &amp;quot;nelmio/api-doc-bundle&amp;quot; &amp;quot;@dev&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then we had to configure the bundles properly and add to the appKernel.php&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// app/AppKernel.php
$bundles = array(
    //..
    new FOS\RestBundle\FOSRestBundle(),
    new JMS\SerializerBundle\JMSSerializerBundle(),
    new Nelmio\ApiDocBundle\NelmioApiDocBundle(),&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='step_1b_the_blog_bundle'&gt;Step 1.B The Blog Bundle&lt;/h2&gt;

&lt;p&gt;We are going to create a REST controller for the Page Entity, in your symfony2 standard application we need to create the bundle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app/console generate:bundle --namespace=Acme/BlogBundle --dir=src --no-interaction&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='step_1c_the_model'&gt;Step 1.C The Model&lt;/h2&gt;

&lt;p&gt;We are going to create an Entity called &lt;code&gt;Page&lt;/code&gt; with &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php app/console doctrine:generate:entity --entity=AcmeBlogBundle:Page \
  --format=annotation --fields=&amp;quot;title:string(255) body:text&amp;quot; \
  --no-interaction
php app/console doctrine:database:create
php app/console doctrine:schema:create&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='step_1d_the_page_form'&gt;Step 1.D The Page Form&lt;/h2&gt;

&lt;p&gt;Now we need the form for that entity, another generator command :)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;php app/console doctrine:generate:form AcmeBlogBundle:Page --no-interaction&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='step_2__start_with_rest'&gt;Step 2 - Start with Rest&lt;/h2&gt;

&lt;h3 id='step_2a__the_functional_test'&gt;Step 2.A - The functional test&lt;/h3&gt;

&lt;p&gt;We want to create a function that when it&amp;#8217;s called it returns the resource with the format requested.&lt;/p&gt;

&lt;p&gt;Any good controller should start with a Functional test, but in order to reduce the verbosity I&amp;#8217;ll talk about functional test later, see the section 3.C below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. /api/v1/pages/{id}.{_format}
2. /api/v1/pages/{id}.json  # will return a json file
3. /api/v1/pages/{id}.xml   # will return a xml file
4. /api/v1/pages/{id} and /api/1/pages/{id}.html  # will return the web page file&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;#8217;ll see later how to not explicitly specify the format, and how to use and set-up correctly the content-negotiation using HTTP Headers.&lt;/p&gt;

&lt;h3 id='step_2b__the_controller'&gt;Step 2.B - The controller&lt;/h3&gt;

&lt;p&gt;We want to create the controller class&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// /src/Acme/BlogBundle/Controller/PageController.php
class PageController extends FOSRestController&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then we add a simple and dirty function (we&amp;#8217;ll refactor soon)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function getPageAction($id)
{
    return $this-&amp;gt;container-&amp;gt;get(&amp;#39;doctrine.entity_manager&amp;#39;)-&amp;gt;getRepository(&amp;#39;Page&amp;#39;)-&amp;gt;find($id);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='edit14112013_samuel_gordalina_suggests'&gt;&lt;strong&gt;&lt;span&gt;EDIT-14/11/2013&lt;/span&gt;&lt;/strong&gt; Samuel Gordalina suggests:&lt;/h4&gt;

&lt;p&gt;You can use ParamConverter which fetches an entity from database or returns a 404 exception. For more info see &lt;a href='https://github.com/gordalina/sample-twitter-api-symfony2/blob/master/src/Twitter/ApiBundle/Controller/TweetController.php#L37'&gt;sample-twitter-api-symfony2:37&lt;/a&gt;&lt;/p&gt;

&lt;h3 id='step_2c__adding_the_routes'&gt;Step 2.C - Adding the routes&lt;/h3&gt;

&lt;p&gt;Add to the route file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# /app/config/routing.yml
acme_blog:
    type: rest
    prefix: /api
    resource: &amp;quot;@AcmeBlogBundle/Resources/config/routes.yml&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a route file into the bundle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# /src/Acme/BlogBundle/Resources/config/routes.yml
acme_blog_Page:
    type: rest
    prefix: /v1
    resource: &amp;quot;Acme\BlogBundle\Controller\PageController&amp;quot;
    name_prefix:  api_1_ # naming collision&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;check all the API routes with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app/console route:debug | grep api&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it should contain the &lt;code&gt;api_1_get_page&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So we now have a route, and a controller that responses to the get(id) with the Page resource, is that what we wanted?&lt;/p&gt;

&lt;p&gt;Yes but we could do better.&lt;/p&gt;

&lt;h2 id='step_3__refactoring'&gt;Step 3 - Refactoring&lt;/h2&gt;

&lt;p&gt;OMG we have only created a little Controller, why we need to refactor?&lt;/p&gt;

&lt;p&gt;As I said we are trying to do things at our best, while this may seem over-engineering, in later articles we will see how take advantage of the changes made.&lt;/p&gt;

&lt;h3 id='step_3a__interface_as_contract'&gt;Step 3.A - Interface as contract&lt;/h3&gt;

&lt;p&gt;From &lt;a href='http://symfony.com'&gt;symfony.com&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
Type hinting the injected object means that you can be sure that a suitable dependency has been injected.
By type-hinting, you'll get a clear error immediately if an unsuitable dependency is injected.
By type hinting using an interface rather than a class you can make the choice of dependency more flexible.
And assuming you only use methods defined in the interface, you can gain that flexibility and still safely use the object.
&lt;/blockquote&gt;
&lt;p&gt;Following this as first rule, we need to create an interface in &lt;code&gt;/src/Acme/BlogBundle/Model/PageInterface.php&lt;/code&gt; and then put &lt;code&gt;implements PageInterface&lt;/code&gt; in the entity &lt;code&gt;Page&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id='step_3b__the_page_handler'&gt;Step 3.B - The Page Handler&lt;/h3&gt;

&lt;p&gt;In order to remove all the logic from the &lt;code&gt;PageController&lt;/code&gt;, we have to create a service, we call it &lt;code&gt;PageHandler&lt;/code&gt; in &lt;code&gt;/src/Acme/BlogBundle/Handler/PageHandler.php&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The test for the the &lt;code&gt;PageHandler&lt;/code&gt; looks something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// /src/Acme/BlogBundle/Tests/Handler/PageHandlerTest.php:45
public function testGet()
{
    $id = 1;
    $page = $this-&amp;gt;getPage(); // create a Page object
    // I expect that the Page repository is called with find(1)
    $this-&amp;gt;repository-&amp;gt;expects($this-&amp;gt;once())
        -&amp;gt;method(&amp;#39;find&amp;#39;)
        -&amp;gt;with($this-&amp;gt;equalTo($id))
        -&amp;gt;will($this-&amp;gt;returnValue($page));

    $this-&amp;gt;pageHandler-&amp;gt;get($id); // call the get.
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it uses &lt;code&gt;find&lt;/code&gt; to fetch an &lt;code&gt;id&lt;/code&gt; using the doctrine repository.&lt;/p&gt;

&lt;p&gt;We are going to create the effective &amp;#8216;Handler&amp;#8217; that will manage all the transactions to the persistence layer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// /src/Acme/BlogBundle/Handler/PageHandler.php:16
class PageHandler implements PageHandlerInterface
{
    // ..
    public function __construct(ObjectManager $om, $entityClass)
    {
        $this-&amp;gt;om = $om;
        $this-&amp;gt;entityClass = $entityClass;
        $this-&amp;gt;repository = $this-&amp;gt;om-&amp;gt;getRepository($this-&amp;gt;entityClass);
    }

    // ...
    public function get($id)
    {
        return $this-&amp;gt;repository-&amp;gt;find($id);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to make this class available as a service from the dependency injection:&lt;/p&gt;

&lt;p&gt;/src/Acme/BlogBundle/Resources/config/services.xml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;parameters&amp;gt;
    &amp;lt;parameter key=&amp;quot;acme_blog.page.handler.class&amp;quot;&amp;gt;Acme\BlogBundle\Handler\PageHandler&amp;lt;/parameter&amp;gt;
    &amp;lt;parameter key=&amp;quot;acme_blog.page.class&amp;quot;&amp;gt;Acme\BlogBundle\Entity\Page&amp;lt;/parameter&amp;gt;
&amp;lt;/parameters&amp;gt;

&amp;lt;services&amp;gt;
    &amp;lt;service id=&amp;quot;acme_blog.page.handler&amp;quot; class=&amp;quot;%acme_blog.page.handler.class%&amp;quot;&amp;gt;
        &amp;lt;argument type=&amp;quot;service&amp;quot; id=&amp;quot;doctrine.orm.entity_manager&amp;quot; /&amp;gt;
        &amp;lt;argument&amp;gt;%acme_blog.page.class%&amp;lt;/argument&amp;gt;
    &amp;lt;/service&amp;gt;
&amp;lt;/services&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='step_3c__thin_controller'&gt;Step 3.C - Thin Controller&lt;/h3&gt;

&lt;p&gt;Now we have to refactor the controller in order to follow the modification above and use the &lt;code&gt;PageHandler&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id='the_functional_test_for_the_controller'&gt;The functional test for the controller:&lt;/h4&gt;

&lt;p&gt;first add to your &lt;code&gt;composer.json&lt;/code&gt; the require-dev section:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;require-dev&amp;quot;: {
    &amp;quot;doctrine/doctrine-fixtures-bundle&amp;quot;: &amp;quot;dev-master&amp;quot;,
    &amp;quot;phpunit/phpunit&amp;quot;: &amp;quot;3.7.*&amp;quot;,
    &amp;quot;liip/functional-test-bundle&amp;quot;:&amp;quot;dev-master&amp;quot;
},&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then we have to update the dependencies running &lt;code&gt;php composer.phar update&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;There&amp;#8217;s a lot to say about the functional test, we are going to test that when the &lt;code&gt;api_1_get_page&lt;/code&gt; is called, it should return a response with &lt;code&gt;200&lt;/code&gt;, the type of the content should be &lt;code&gt;json&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;liip/functional-test-bundle&lt;/code&gt; helps us to handle the fixtures data to the persistence layer before each test.&lt;/p&gt;

&lt;p&gt;First we configure &lt;code&gt;fos_rest&lt;/code&gt; in order to handle correct format see: &lt;code&gt;/app/config/config.yml:69&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We have to create the fixture class see &lt;code&gt;/src/Acme/BlogBundle/Tests/Fixtures/Entity/LoadPageData.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;and the test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function testGet()
{
    $fixtures = array(&amp;#39;Acme\BlogBundle\Tests\Fixtures\Entity\LoadPageData&amp;#39;);
    $this-&amp;gt;customSetUp($fixtures);
    $page = array_pop(LoadPageData::$pages);

    $route =  $this-&amp;gt;getUrl(&amp;#39;api_1_get_page&amp;#39;, array(&amp;#39;id&amp;#39; =&amp;gt; $page-&amp;gt;getId(), &amp;#39;_format&amp;#39; =&amp;gt; &amp;#39;json&amp;#39;));
    $this-&amp;gt;client-&amp;gt;request(&amp;#39;GET&amp;#39;, $route);
    $response = $this-&amp;gt;client-&amp;gt;getResponse();
    $this-&amp;gt;assertJsonResponse($response, 200);
    $content = $response-&amp;gt;getContent();

    $decoded = json_decode($content, true);
    $this-&amp;gt;assertTrue(isset($decoded[&amp;#39;id&amp;#39;]));
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The assertJsonResponse function is well described here: &lt;a href='http://williamdurand.fr/2012/08/02/rest-apis-with-symfony2-the-right-way/#testing'&gt;williamdurand-rest-apis-with-symfony2-the-right-way/#testing&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;the full test is visible here: /src/Acme/BlogBundle/Tests/Controller/PageControllerTest.php&lt;/p&gt;

&lt;p&gt;We have now to modify the function &lt;code&gt;getPage($id)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// /src/Acme/BlogBundle/Controller/PageController.php

/**
 * Get single Page,
 *
 * @ApiDoc(
 *   resource = true,
 *   description = &amp;quot;Gets a Page for a given id&amp;quot;,
 *   output = &amp;quot;Acme\BlogBundle\Entity\Page&amp;quot;,
 *   statusCodes = {
 *     200 = &amp;quot;Returned when successful&amp;quot;,
 *     404 = &amp;quot;Returned when the page is not found&amp;quot;
 *   }
 * )
 *
 * @Annotations\View(templateVar=&amp;quot;page&amp;quot;)
 *
 * @param Request $request the request object
 * @param int     $id      the page id
 *
 * @return array
 *
 * @throws NotFoundHttpException when page not exist
 */
public function getPageAction($id)
{
    $page = $this-&amp;gt;container
        -&amp;gt;get(&amp;#39;acme_blog.blog_post.handler&amp;#39;)
        -&amp;gt;get($id);

    return $page;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;executing the test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/phpunit -c app&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Woow green test!&lt;/p&gt;

&lt;p&gt;The bundle looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;src/Acme/BlogBundle/
    ├── AcmeBlogBundle.php
    ├── Controller
    │   └── PageController.php
    ├── DependencyInjection
    ├── Entity
    │   └── Page.php
    ├── Form
    │   └── PageType.php
    ├── Handler
    │   ├── PageHandlerInterface.php
    │   └── PageHandler.php
    ├── Model
    │   └── PageInterface.php
    ├── Resources
    └── Tests
        ├── Controller
        │   └── PageControllerTest.php
        ├── Fixtures
        │   └── Entity
        │       └── LoadPageData.php
        └── Handler
            └── PageHandlerTest.php&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='accessing_to_the_response'&gt;Accessing to the response&lt;/h2&gt;

&lt;p&gt;Is time to see how the application responses, so executing the php http server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app/console server:run &amp;amp;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then accessing to the the resource with &lt;code&gt;wget&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget -S  localhost:8000/api/v1/pages/0.html&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will have a &lt;code&gt;500&lt;/code&gt; because the database is empty, and that resource doesn&amp;#8217;t exists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--2013-11-09 15:46:37--  http://localhost:8000/api/v1/pages/0.html
Connecting to localhost (localhost)|127.0.0.1|:8000... connected.
HTTP request sent, awaiting response... 
  HTTP/1.0 500 Internal Server Error
  Content-type: text/html
2013-11-09 15:46:37 ERROR 500: Internal Server Error.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resource &amp;#8216;0&amp;#8217; doesn&amp;#8217;t exists, but we want that the status codes reflects the application behaviour, so it should return a &lt;code&gt;404&lt;/code&gt; resource not found.&lt;/p&gt;

&lt;p&gt;We are going to create a private function that throws an Exception if the &lt;code&gt;Page&lt;/code&gt; is not found, the Exception will modify also automatically the Response Header.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Fetch the Page or throw a 404 exception.
 *
 * @param mixed $id
 *
 * @return PageInterface
 *
 * @throws NotFoundHttpException
 */
protected function getOr404($id)
{
    if (!($page = $this-&amp;gt;container-&amp;gt;get(&amp;#39;acme_blog.blog_post.handler&amp;#39;)-&amp;gt;get($id))) {
        throw new NotFoundHttpException(sprintf(&amp;#39;The resource \&amp;#39;%s\&amp;#39; was not found.&amp;#39;,$id));
    }

    return $page;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The controller now should use this function and executing &lt;code&gt;wget -S  localhost:8000/api/v1/pages/0.html&lt;/code&gt;, we receive a &lt;code&gt;404&lt;/code&gt; and we are happy :)&lt;/p&gt;

&lt;h2 id='content_negotiation'&gt;Content Negotiation&lt;/h2&gt;

&lt;p&gt;An important concept developing the REST API is the &lt;a href='http://en.wikipedia.org/wiki/Content_negotiation'&gt;Content Negotiation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you think that everything is a resource, maybe you care also about the name of the resource, if the page &lt;code&gt;10&lt;/code&gt; is at &lt;code&gt;/api/v1/pages/10&lt;/code&gt;, you may want to retrieve the same resource with different content type, not specifying the &lt;code&gt;format&lt;/code&gt; explicitly in the extension &lt;code&gt;/api/v1/pages/10.html&lt;/code&gt;, but instead using HTTP &lt;code&gt;Accept&lt;/code&gt; header.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;EDIT&lt;/span&gt; removed the tags content-negotiation. If you want to play with the rest application without the extension, set false to &lt;code&gt;prefer_extension&lt;/code&gt; here:&lt;code&gt;https://github.com/liuggio/symfony2-rest-api-the-best-2013-way/blob/master/app/config/config.yml#L102&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Request: &lt;code&gt;curl -i localhost:8000/api/v1/pages/10&lt;/code&gt; No Accept header is sent so the fallback is &lt;code&gt;text/html&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Host: localhost:8000
Content-Type: text/html; charset=UTF-8
Allow: GET

&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;10- title&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;body&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we retrieve the same resource changing the header:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -i -H &amp;quot;Accept: application/json&amp;quot;  localhost:8000/api/v1/pages/10&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tadaaaam the response is a json file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Host: localhost:8000
Content-Type: application/json
Allow: GET

{&amp;quot;id&amp;quot;:10,&amp;quot;title&amp;quot;:&amp;quot;title&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;body&amp;quot;}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could also send different Content type accepted with different preferences eg:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -i -H &amp;quot;Accept: application/json; q=1.0, t/pages/10 q=0.8&amp;quot; localhost:8000/api/v1/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The response will be a json file as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK
Host: localhost:8000
Content-Type: application/json
Allow: GET

{&amp;quot;id&amp;quot;:10,&amp;quot;title&amp;quot;:&amp;quot;title&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;body&amp;quot;}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='recap'&gt;Recap&lt;/h2&gt;

&lt;p&gt;We have created a Doctrine entity called &lt;code&gt;Page&lt;/code&gt;, we have identified the methods of the interface that will be very useful later on. We first created a functional test, then the thin controller without logic. We have created unit test and then the service &lt;code&gt;PageHandler&lt;/code&gt; which instead of the controller, contains the logic to retrieve the information. We understood the importance of Content Negotiation.&lt;/p&gt;

&lt;h2 id='next'&gt;Next&lt;/h2&gt;

&lt;p&gt;In the next articles, we will describe how to use the page form as shared interface, we will create, modify, and delete Pages, with &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, and we will detail how use other important HTTP headers.&lt;/p&gt;

&lt;h3 id='references'&gt;References:&lt;/h3&gt;

&lt;p&gt;&lt;a href='http://www.symfony2.com'&gt;Symfony.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.youtube.com/watch?v=Kkby5fG89K0&amp;amp;feature=youtu.be&amp;amp;from=www.welcometothebundle.com'&gt;Lukas Kahwe Smith: resting with Sf2 - video&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://williamdurand.fr/2012/08/02/rest-apis-with-symfony2-the-right-way/'&gt;William Durand: rest-apis-with-symfony2-the-right-way - blog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='https://speakerdeck.com/gordalina/rest-apis-made-easy-with-symfony2'&gt;Samuel Gordalina: REST APIs made easy with Symfony2 - slide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.slideshare.net/dlondero/rest-in-practice-27335543'&gt;Daniel Londero: Rest in practice - slide&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Symfony2 design patterns @ symfonyday</title>
   <link href="http://welcometothebundle.com/symfony2-design-patterns"/>
   <updated>2013-10-18T00:00:00+02:00</updated>
   <id>http://welcometothebundle.com/symfony2-design-patterns</id>
   <content type="html">&lt;p&gt;I had the good fortune of being able to speech for the second time in a row, on the Symfony-Day conference.&lt;/p&gt;

&lt;p&gt;This time I had a quality partner &lt;a href='http://giorgiocefaro.com/'&gt;mr @giorrrgio (Giorgio Cefaro)&lt;/a&gt;, we talked about design patterns in Symfony2, and even about some Anti-patterns.&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.slideshare.net/liuggio/design-pattern-symfony2'&gt;Design pattern symfony2 - Nanos gigantium humeris insidentes&lt;/a&gt;.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Design by contract behaviour</title>
   <link href="http://welcometothebundle.com/design-by-contract-behaviour"/>
   <updated>2013-09-11T00:00:00+02:00</updated>
   <id>http://welcometothebundle.com/design-by-contract-behaviour</id>
   <content type="html">&lt;p&gt;In recent years, &lt;a href='http://getcomposer.org'&gt;Composer&lt;/a&gt; has given a breath of freshness to the dependencies, and framework such as &lt;a href='http://www.symfony.com'&gt;Symfony2&lt;/a&gt; have made best practices and decoupling their pride.&lt;/p&gt;

&lt;p&gt;The union of these two phenomena have moved the attentions to the type hinting in order to have contracts with &lt;code&gt;Interfaces&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;PHP doesn&amp;#8217;t have the support for &lt;a href='http://en.wikipedia.org/wiki/Structural_type_system'&gt;Structural type system&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='the_problem'&gt;The problem&lt;/h2&gt;

&lt;p&gt;The problem comes when a library uses a functionality of a third library, but do not want to hard-code the third-part library in the namespace&lt;/p&gt;

&lt;h2 id='case_study'&gt;Case Study&lt;/h2&gt;

&lt;p&gt;I have a library that uses a logger:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src/Service/MyService
namespace MyLib\Service;

class MyService

   private $log;

   public function __construct($log)
   {
     this-&amp;gt;log = $log;
   }

   public function doSomethig()
   {
      $this-&amp;gt;log-&amp;gt;info(&amp;#39;log this&amp;#39;);
   }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I want to use the type hinting because that dependency will be called with &lt;code&gt;info&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then I add the type-hinting LoggerInterface, but which namespace to use? I can&amp;#8217;t define a new mine LoggerInterface, so use the Monolog one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// src/Service/MyService
namespace MyLib\Service;

use Monolog\LoggerInterface;

class MyService

   private $log;

   public function __construct(LoggerInterface $log)
   {
     this-&amp;gt;log = $log;
   }

   public function doSomethig()
   {
      $this-&amp;gt;log-&amp;gt;info(&amp;#39;log this&amp;#39;);
   }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doing this I have hardcoded a &lt;strong&gt;dependency&lt;/strong&gt; to the Monolog library, composer.json and this file &lt;code&gt;src/Service/MyService&lt;/code&gt; has to be maintained together, isn&amp;#8217;t smell to you?&lt;/p&gt;

&lt;p&gt;And what happen when I&amp;#8217;ll find a better logger library that has got the same LoggerInterface and the function &amp;#8216;info&amp;#8217;? I&amp;#8217;ve to change the namespace to the new LoggerInterface or the type hinting would fail, because the control for the type hinting is also on the namespace of the interface and not on the behaviour.&lt;/p&gt;

&lt;h2 id='solution'&gt;Solution?&lt;/h2&gt;

&lt;p&gt;Monolog have fixed this problem by putting a shared interface inside PSR &lt;a href='http://www.php-fig.org'&gt;php-fig.org/&lt;/a&gt; repository, but not all cases can be put in the php-fig.&lt;/p&gt;

&lt;p&gt;One solution would be to permit the alias for namespaces.&lt;/p&gt;

&lt;p&gt;Another &lt;code&gt;naive&lt;/code&gt; solution would be modify the &lt;code&gt;php-internal&lt;/code&gt; of how type hinting works, maybe defining an interface with a sort of keyword eg.&lt;code&gt;behaviour&lt;/code&gt; that forces the engine to check that the type that you pass has the same behavior (functions) and not forcing the namespace.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace MyLib;
Behaviour Interface LoggerInterface
{
    public function info($string);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='why'&gt;Why?&lt;/h2&gt;

&lt;p&gt;Can you imagine a world where the libraries are decoupled but they respects the interfaces without sharing file but sharing &lt;code&gt;behaviour&lt;/code&gt;?&lt;/p&gt;

&lt;h2 id='phpfig'&gt;PHP-fig&lt;/h2&gt;

&lt;p&gt;PHP-fig is a great tool but it&amp;#8217;s democratic and democracy on internet is not always able to satisfy the minorities, and to be competitive with the times.&lt;/p&gt;

&lt;h2 id='another_example'&gt;Another example&lt;/h2&gt;

&lt;p&gt;Another example, if you want to use this library http://yohan.giarel.li/Finite/index.html, you have to put a dependency with Finite\StatefulInterface only because your class has to have the functions &lt;code&gt;getFiniteState&lt;/code&gt; and &lt;code&gt;setFiniteState&lt;/code&gt;, this is good and it works but hard-coding namespaces and dependencies is not the best option.&lt;/p&gt;

&lt;h2 id='what_do_you_think_about_it'&gt;What do you think about it?&lt;/h2&gt;

&lt;h2 id='edit'&gt;EDIT&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;That&amp;#8217;s a RFC for that&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Giorgio told me about this RFC: &lt;a href='https://wiki.php.net/rfc/protocol_type_hinting'&gt;php.net/rfc/protocol_type_hinting&lt;/a&gt;.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Caching and data analysis will move your application to the next level</title>
   <link href="http://welcometothebundle.com/caching-and-data-analysis-will-move-your-application-to-the-next-level"/>
   <updated>2013-05-17T00:00:00+02:00</updated>
   <id>http://welcometothebundle.com/caching-and-data-analysis-will-move-your-application-to-the-next-level</id>
   <content type="html">&lt;h3 id='if_you_dont_ignore_data_you_could_find_a_business_value'&gt;If you don&amp;#8217;t ignore data you could find a business value.&lt;/h3&gt;

&lt;p&gt;The presentation focuses on data analysis, how to track and measure applications and why the use of software metrics that push information are essential.&lt;/p&gt;

&lt;p&gt;Delegates will be shown practical examples of how Terravision uses Statsd, Sentry versus Graylog for the error behavior analysis of users, applications, operating systems and web servers.&lt;/p&gt;

&lt;p&gt;The final part of the presentation concludes with methodologies of advanced scalability, events, messages and queues.&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.slideshare.net/liuggio/caching-and-data-analysis-will-move-your-symfony2-application-to-the-next-level'&gt;Caching and data analysis will move your Symfony2 application to the next level&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Doctrine2 tracking policy</title>
   <link href="http://welcometothebundle.com/doctrine2-tracking-policy"/>
   <updated>2013-04-23T00:00:00+02:00</updated>
   <id>http://welcometothebundle.com/doctrine2-tracking-policy</id>
   <content type="html">&lt;h1 id='which_tracking_policy_are_you_using'&gt;Which tracking policy are you using?&lt;/h1&gt;

&lt;p&gt;With doctrine you can change the tracking policy for each entity, the tracking policy is the way in which Doctrine understands if a entity property must be &amp;#8216;saved&amp;#8217; in the database.&lt;/p&gt;

&lt;p&gt;Doctrine definition: &amp;#8220;Change tracking is the process of determining what has changed in managed entities since the last time they were synchronized with the database.&amp;#8221;&lt;/p&gt;

&lt;p&gt;There are 3 tracking policies: Implicit, Explicit, Nofity.&lt;/p&gt;

&lt;h2 id='implicit_tracking_the_default_one'&gt;Implicit tracking (the default one)&lt;/h2&gt;

&lt;p&gt;The implicit is the default one and the slowest, you don&amp;#8217;t need to explicit call &amp;#8216;persist&amp;#8217; eg.&lt;/p&gt;

&lt;p&gt;&lt;code&gt; // $entity is not a new object, and has $entity-&amp;gt;Title = &amp;#39;liuggio loves tvision.github.io&amp;#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; $entity-&amp;gt;setTitle(&amp;#39;liuggio loves symfony2&amp;#39;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; $entityManager-&amp;gt;flush();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; echo $entity-&amp;gt;getTitle();   // output &amp;#39;liuggio loves symfony2&amp;#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Unit of work now has &lt;strong&gt;$entity.title=liuggio loves symfony2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Database has flushed without persist &lt;strong&gt;$entity.title=liuggio loves symfony2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;: &lt;code&gt;$entityManager-&amp;gt;persist($entity)&lt;/code&gt; is not necessary&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cons&lt;/strong&gt;: Slowness, Doctrine has to check property-by-property for all the object in the unit of work&lt;/p&gt;

&lt;h2 id='the_explicit_tracking_the_suggested_one'&gt;The explicit tracking (the suggested one)&lt;/h2&gt;

&lt;p&gt;You have to explicit flag which object you want to persist, than Doctrine will check property-by-property in order to find with property has changed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;: Faster than implicit, must if you have a lot of entities.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cons&lt;/strong&gt;: the object in the unit of work could be different from that one in the db, not easy to debug.&lt;/p&gt;

&lt;p&gt;The example&lt;/p&gt;

&lt;p&gt;&lt;code&gt; // $entity is not a new object, and has $entity-&amp;gt;Title = &amp;#39;liuggio loves tvision.github.io&amp;#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; $entity-&amp;gt;setTitle(&amp;#39;liuggio loves symfony2&amp;#39;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; $entityManager-&amp;gt;flush();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; echo $entity-&amp;gt;getTitle();   // output &amp;#39;liuggio loves symfony2&amp;#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Unit of work now has &lt;strong&gt;$entity.title=liuggio loves symfony2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Database has different state for that entity &lt;strong&gt;liuggio loves tvision.github.io&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id='notify_tracking'&gt;Notify tracking&lt;/h2&gt;

&lt;p&gt;It&amp;#8217;s not really a tracking policy, if you want to develop your own tracking policy, you have the tool for doing it.&lt;/p&gt;

&lt;p&gt;Don&amp;#8217;t understimate this policy useful if you a domain logic.&lt;/p&gt;

&lt;h2 id='link_to_doctrine_doc'&gt;Link to doctrine doc&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://docs.doctrine-project.org/en/latest/reference/change-tracking-policies.html'&gt;doctrine/change-tracking-policies&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>It is all about behaviour also in php</title>
   <link href="http://welcometothebundle.com/it-is-all-about-behaviour-also-in-php"/>
   <updated>2013-03-10T00:00:00+01:00</updated>
   <id>http://welcometothebundle.com/it-is-all-about-behaviour-also-in-php</id>
   <content type="html">&lt;p&gt;It is a shame I never had energy to continue the BDD saga started with: &lt;a href='http://welcometothebundle.com/phpunit-vs-phpspec-theory-on-behaviour-driven-development'&gt;phpunit-vs-phpspec-theory-on-behaviour-driven-development 1/3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;During our monthly meeting at &lt;a href='http://roma.grusp.org/2013/03/incontro-di-febbraio-2013/'&gt;Pug Roma&lt;/a&gt;, I have talked about php-spec and behaviour driven development.&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.slideshare.net/liuggio/its-all-about-behaviour-also-in-php'&gt;phpspec/It is all about behaviour also in php&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>The meaning of Cache for a web developer no more too many connection</title>
   <link href="http://welcometothebundle.com/the-meaning-of-cache-for-a-web-developer-no-more-too-many-connection"/>
   <updated>2013-02-22T00:00:00+01:00</updated>
   <id>http://welcometothebundle.com/the-meaning-of-cache-for-a-web-developer-no-more-too-many-connection</id>
   <content type="html">&lt;p&gt;In the place of Mr. Obvious I&amp;#8217;m going to describe what really cache means, there is a lot of confusion between what the cache &lt;strong&gt;is&lt;/strong&gt;, what it &lt;strong&gt;does&lt;/strong&gt; and all the possible &lt;strong&gt;uses&lt;/strong&gt; and &lt;strong&gt;implementations&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;All the fuss comes from the use&lt;strong&gt;s&lt;/strong&gt; of that polysemous word.&lt;/p&gt;

&lt;h2 id='definition'&gt;Definition:&lt;/h2&gt;

&lt;p&gt;We should start from &lt;strong&gt;Wikipedia&lt;/strong&gt;, “Cache is a component that transparently stores data so that future requests for that data can be served faster.”&lt;/p&gt;

&lt;p&gt;So instead of doing a time consuming calculation if you already &amp;#8216;remember&amp;#8217; the result answer it.&lt;/p&gt;

&lt;p&gt;The concept seems simple, the problem is it could be used in a myriad of ways.&lt;/p&gt;

&lt;p&gt;Important words:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;strong&gt;Cache Hit&lt;/strong&gt; happens if the Cache contains the answer.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;A &lt;strong&gt;Cache Miss&lt;/strong&gt; happens if the Cache doesn’t contain the answer.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id='some_standard_code'&gt;Some &amp;#8216;standard&amp;#8217; Code:&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Doctrine&lt;/strong&gt; defines the cache interface with &lt;a href='https://github.com/doctrine/cache/blob/master/lib/Doctrine/Common/Cache/Cache.php'&gt;Doctrine/Common/Cache/Cache.php&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fetch($id);
function contains($id);
function save($id, $data, $lifeTime = 0);
function delete($id);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;PHP fig-standards&lt;/strong&gt; proposed the cache with &lt;a href='https://github.com/php-fig/fig-standards/issues?labels=Cache&amp;amp;page=1&amp;amp;state=open'&gt;proposed/PSR-Cache.md&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='implementations'&gt;Implementations:&lt;/h2&gt;

&lt;p&gt;As web developers the cache is an essential tool, we have to divide the cache features from its implementations.&lt;/p&gt;

&lt;h3 id='1_http_cache'&gt;1. HTTP Cache&lt;/h3&gt;

&lt;h4 id='description'&gt;Description&lt;/h4&gt;

&lt;p&gt;OK - describing the HTTP Cache is a huge task, and heaps of great developers already did this (&lt;a href='https://www.google.com/search?q=http+cache'&gt;google&lt;/a&gt;, &lt;a href='http://www.slideshare.net/fabpot/caching-on-the-edge'&gt;fabpot/caching-on-the-edge&lt;/a&gt;), the concept in few lines is that you are a web developer, and the web works with the HTTP Protocol, so you HAVE to study the HTTP Protocol.&lt;/p&gt;

&lt;p&gt;I won&amp;#8217;t go in depth with HTTP Protocol and Cache, but understanding the HTTP protocol turns a developer in a web developer.&lt;/p&gt;

&lt;p&gt;The actors in the HTTP Cache are: your web-server, your reverse proxy (as Varnish or Squid), the Shared cache server&lt;strong&gt;s&lt;/strong&gt; (more than one) and the client browser cache.&lt;/p&gt;

&lt;p&gt;This is the best Cache and the most powerful, you could create many cache layers on your application, but if you set up the HTTP headers properly the first time, the next requests will be served for free. &lt;strong&gt;The least expensive query is the query you never had&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id='enemies'&gt;Enemies&lt;/h4&gt;

&lt;p&gt;An enemy of your mental health is the &lt;strong&gt;invalidation&lt;/strong&gt;, do not waste time trying to find a solutions for invalidating cache, choose only the best validation.&lt;/p&gt;

&lt;p&gt;The HTTP cache enemy? Cookies and Sessions (see how to solve it thanks to &lt;a href='https://www.google.it/search?client=ubuntu&amp;amp;channel=fs&amp;amp;q=ESI+cache&amp;amp;ie=utf-8&amp;amp;oe=utf-8&amp;amp;redir_esc=&amp;amp;ei=P6QnUbS5AsbKtAbdQQ'&gt;ESI&lt;/a&gt;)&lt;/p&gt;

&lt;h4 id='best_tools'&gt;Best Tools&lt;/h4&gt;

&lt;p&gt;Varnish / Squid&lt;/p&gt;

&lt;h3 id='2_opcode'&gt;2. Opcode&lt;/h3&gt;

&lt;h4 id='description'&gt;Description&lt;/h4&gt;

&lt;p&gt;“APC is a performance-enhancing extension. It should not be confused with a magic pill, although having it around does provide a positive impact on performance! If configured incorrectly, APC can cause unexpected behaviour, however when implemented optimally APC can be a useful weapon in your arsenal.” &lt;a href='http://techportal.inviqa.com/2010/10/07/understanding-apc/'&gt;read more on understanding APC&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This should be a must for you my dear PHP developer.&lt;/p&gt;

&lt;h4 id='best_tools'&gt;Best Tools&lt;/h4&gt;

&lt;p&gt;APC o Zend Optimizer+.&lt;/p&gt;

&lt;h3 id='3_the_cache_of_your_application__framework'&gt;3. The Cache of your application / framework&lt;/h3&gt;

&lt;h4 id='description'&gt;Description&lt;/h4&gt;

&lt;p&gt;The framework is a tool that should helps you sort and easily create the logic of your domain, to do this it provides files and configurators, which are usually elaborated in PHP files, the cache is used to not process at each request.&lt;/p&gt;

&lt;p&gt;For example with Symfony2 in the application cache folders you will find, Url creator files, Proxy Classes, Configuration files (ini, yml, xml) converted to PHP files, Annotations etc&amp;#8230;&lt;/p&gt;

&lt;h4 id='best_tools'&gt;Best Tools&lt;/h4&gt;

&lt;p&gt;Configuration file to PHP then any Opcode.&lt;/p&gt;

&lt;h3 id='4_template_and_file_system_caching'&gt;4. Template and File System Caching&lt;/h3&gt;

&lt;h4 id='description'&gt;Description&lt;/h4&gt;

&lt;p&gt;Good Template engines, Smarty and Twig provide a caching system using precompiled pieces of code already in a file into the file system.&lt;/p&gt;

&lt;h4 id='best_tools'&gt;Best Tools&lt;/h4&gt;

&lt;p&gt;There is no better cache then the Opcode for serving this type of file.&lt;/p&gt;

&lt;p&gt;Recently a Pull Request has also been refused, it allows Twig to use any other type of cache &lt;a href='https://github.com/fabpot/Twig/issues/728'&gt;issue on github&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id='5_query_results'&gt;5. Query Results&lt;/h3&gt;

&lt;h4 id='description'&gt;Description&lt;/h4&gt;

&lt;p&gt;You are Object Oriented programmers, do not waste your time normalizing the database, if you have too many JOIN delegated the speed to the cache layer.&lt;/p&gt;

&lt;p&gt;Queries can be large objects, better to put a centralized server, The enemy is the period of validity vs. freshness, and the size of the query.&lt;/p&gt;

&lt;h4 id='best_tools'&gt;Best Tools&lt;/h4&gt;

&lt;p&gt;Redis/Memcache(d), but &lt;a href='http://www.slideshare.net/uptimeforce/postgresql-query-cache-pqc'&gt;PostgreSQL-cache&lt;/a&gt; has a great internal cache layer, also MySQL has it.&lt;/p&gt;

&lt;h3 id='6_query_caching'&gt;6. Query Caching&lt;/h3&gt;

&lt;h4 id='description'&gt;Description&lt;/h4&gt;

&lt;p&gt;Some ORM as Doctrine stores the query creation in order to not process it twice.&lt;/p&gt;

&lt;h4 id='best_tools'&gt;Best Tools&lt;/h4&gt;

&lt;p&gt;APC or Redis/Memcache(d)&lt;/p&gt;

&lt;h2 id='simple_rules'&gt;Simple Rules&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;If you want to not process content of ini files or xml files or yml files, you could convert to PHP or you could store data see &lt;strong&gt;3.&lt;/strong&gt;&lt;/li&gt;

&lt;li&gt;If you want to cache PHP files use Opcode caching.&lt;/li&gt;

&lt;li&gt;If you want to store variable contents or Objects use Redis, Memcache(d), or you could also use APC &lt;a href='http://php.net/manual/en/function.apc-store.php'&gt;apc-store&lt;/a&gt; (suggested if you have a single web server)&lt;/li&gt;

&lt;li&gt;If you have provide some content use HTTP Cache always and in order to serve assets (file css, js, static content) use some famous CDN or Nginx or some free/cheap cdn service on the net.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='other_cache_mechanisms'&gt;Other Cache mechanisms&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Pre-Caching/Cacheback, sometimes you need to have some data already available and you don&amp;#8217;t want that the first request wait some slow task &lt;a href='http://codeinthehole.com/writing/cacheback-asynchronous-cache-refreshing-for-django'&gt;cacheback-asynchronous-cache-refreshing-for-django&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;a href='http://www.howtoforge.com/why-you-should-always-use-nginx-with-microcaching'&gt;Microcaching&lt;/a&gt;, few seconds of cache, useful for GET or &lt;strong&gt;POST&lt;/strong&gt;. I said &lt;strong&gt;POST&lt;/strong&gt;, do not it seemed strange to you? If you jumped on the chair is ok, POST on cache is insane, unless you do not want to avoid double click.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Before there were static website in HTML, then dynamic languages ​​and databases, and we finally came to the static pages again, this blog has been developed with &lt;a href='http://jekyllbootstrap.com/lessons/jekyll-introduction.html'&gt;jekyll&lt;/a&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>PHPUnit vs PHPSpec: theory on Behaviour Driven Development 1/3</title>
   <link href="http://welcometothebundle.com/phpunit-vs-phpspec-theory-on-behaviour-driven-development"/>
   <updated>2013-01-05T00:00:00+01:00</updated>
   <id>http://welcometothebundle.com/phpunit-vs-phpspec-theory-on-behaviour-driven-development</id>
   <content type="html">&lt;p&gt;The first part of a series of short articles (maybe three) where I&amp;#8217;d like to share my tiny experience with BDD and in particular with PHPSpec.&lt;/p&gt;

&lt;h2 id='phpunit_vs_phpspec_a_word_on_behaviour_testing'&gt;PHPUnit vs &lt;a href='https://github.com/phpspec/phpspec2'&gt;PHPSpec&lt;/a&gt;: A word on behaviour testing&lt;/h2&gt;

&lt;p&gt;I recently discovered that there is an alternative to PHPUnit, and I really like this new approach.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; But why an alternative if PHPUnit does everything I need?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; What could be changed is the way of doing test,&lt;/p&gt;

&lt;p&gt;If you&amp;#8217;ve ever worked in TDD, you know it&amp;#8217;s very time consuming&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;create - create or modify the test&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;fail - see it fail&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;pass - code the minimum to get the test passed&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;refactor - Refactoring&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;go to step 1&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='the_differences_in_a_sentence'&gt;The differences in a sentence&lt;/h2&gt;

&lt;p&gt;If the story is a key of the development, the behaviour is the differrence between TDD and BDD.&lt;/p&gt;

&lt;p&gt;If you need to test the insertion of an object into a collection and the collection is represented by an Array, with xUnit you should assert that the collection contains the object in the Array, but if the collection will change to another type of container, graph for example, the xUnit will fail, even if the behaviour is unchanged. In BDD you are not testing you are describing what that classes will do, and so you can continue creating the class (PHPSpec will create the class and the methods for you)&lt;/p&gt;

&lt;h2 id='bdd'&gt;BDD&lt;/h2&gt;

&lt;p&gt;There are several BDD frameworks on PHP depending on what you want to test.&lt;/p&gt;

&lt;h4 id='external_behaviour'&gt;External behaviour&lt;/h4&gt;

&lt;p&gt;&lt;a href='http://behat.org/'&gt;Behat&lt;/a&gt; deals to have specifications that reflects the environment from the outside.&lt;/p&gt;

&lt;h4 id='internal_behaviour'&gt;Internal behaviour&lt;/h4&gt;

&lt;p&gt;&lt;a href='https://github.com/phpspec/phpspec2'&gt;PHPSpec&lt;/a&gt; responds to the behaviour in the lower level, from the internal of the classes.&lt;/p&gt;

&lt;p&gt;&lt;a href='https://github.com/phpspec/phpspec2'&gt;PHPSpec&lt;/a&gt; is considered a tool that helps you to develop.&lt;/p&gt;

&lt;h2 id='summary'&gt;Summary&lt;/h2&gt;

&lt;p&gt;The BDD tests what the object does instead of what it is, and what it does is much more important.&lt;/p&gt;

&lt;p&gt;We have to say that Ruby community helped a lot the evolution of BDD, RSpec is a standard-de-facto, in Ruby world.&lt;/p&gt;

&lt;h2 id='faq'&gt;FAQ&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; When I should use PHPUnit and when to use &lt;a href='https://github.com/phpspec/phpspec2'&gt;PHPSpec&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; There isn&amp;#8217;t a better way between the two, depending on how you want to approach the problem, if you want to follow the behaviour or a unit test the code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; With PHPUnit I could do the same things as I could do with &lt;a href='https://github.com/phpspec/phpspec2'&gt;PHPSpec&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; Absolutely, in fact there is a mapping between the two&lt;/p&gt;

&lt;p&gt;• Assertion Becomes expectation.&lt;/p&gt;

&lt;p&gt;• Test method Becomes code example&lt;/p&gt;

&lt;p&gt;• Test case example Becomes group&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BUT&lt;/strong&gt; You would be distracted by the code loosing focus on the result, and you might miss the concept of behaviour. [EDITED 07-01-2013 thanks to &lt;a href='http://twitter.com/euxpom'&gt;euxpom &lt;img alt='exupom' src='http://gravatar.com/avatar/77014411a56fa9c746d6a89b7fd96121?size=20' /&gt;&lt;/a&gt;]&lt;/p&gt;

&lt;h2 id='phpspec_advantages'&gt;&lt;a href='https://github.com/phpspec/phpspec2'&gt;PHPSpec&lt;/a&gt; advantages&lt;/h2&gt;

&lt;p&gt;xSpec is context specific, expectation, the output is the documentation and it is for this reason that the language is used because the same syntax you guide you to focus in behaviour, and the importance of documentation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/phpspec run -f prettify -v&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the big change is on how you write test code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In the next post I will show some examples on how you could use &lt;a href='https://github.com/phpspec/phpspec2'&gt;PHPSpec&lt;/a&gt; to test some (in)famous design pattern.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id='bibliography'&gt;Bibliography&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href='http://pragprog.com/book/achbd/the-rspec-book'&gt;The RSpec Book Behaviour-Driven Development with RSpec, Cucumber, and Friends&lt;/a&gt; by David Chelimsky, Dave Astels, Zach Dennis, Aslak Hellesøy, Bryan Helmkamp, Dan North&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Test Driven Development. By Example di Kent Beck (dic. 2002)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content>
 </entry>
 
 <entry>
   <title>Automate Test and Code Inspection in PHP with Guard, and Symfony2</title>
   <link href="http://welcometothebundle.com/automate-test-and-code-inspection-in-php-with-guard-and-symfony2"/>
   <updated>2013-01-03T00:00:00+01:00</updated>
   <id>http://welcometothebundle.com/automate-test-and-code-inspection-in-php-with-guard-and-symfony2</id>
   <content type="html">&lt;h2 id='hey_phper_do_you_automate_your_test'&gt;Hey PHPer do you automate your test?&lt;/h2&gt;

&lt;p&gt;In everyday life there are tools that can not only speed, but also lighten the workload of your mind, in that regard I wanted to share a useful library: &lt;a href='https://github.com/guard/guard'&gt;Guard&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id='_guard'&gt;&lt;code&gt;Watch&lt;/code&gt; Guard!&lt;/h2&gt;

&lt;p&gt;&lt;a href='https://github.com/guard/guard'&gt;Guard&lt;/a&gt; is written in Ruby, it automates commands based on events that happen in the filesystem.&lt;/p&gt;

&lt;p&gt;&lt;a href='https://github.com/guard/guard'&gt;Guard&lt;/a&gt; in a short time has become popular especially in the automate testing.&lt;/p&gt;

&lt;p&gt;You can easily edit your files, having only the front window of your editor/IDE, each change will run the test, and you will be notified.&lt;/p&gt;

&lt;p&gt;Indeed during these years of development, especially in PHP I overstimulated shortcuts, I have become a slave of the keyboard, &lt;strong&gt;Alt-Tab&lt;/strong&gt;, &lt;strong&gt;Key-Up + Enter&lt;/strong&gt; for example, are a must for TDD programmers .&lt;/p&gt;

&lt;p&gt;For years I had the &lt;strong&gt;CTRL+S&lt;/strong&gt; tic, in fact in my life I have saved (by mistake) around 2000 pages browsing with Firefox.&lt;/p&gt;

&lt;p&gt;Before finding out &lt;a href='https://github.com/guard/guard'&gt;Guard&lt;/a&gt;, I was using a crude one-line script, it runs each 3 seconds PHPUnit if error otherwise waits 10 seconds&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while true; do clear; phpunit; if [ ! $? ]; then sleep 10; else sleep 3;fi; done;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but it was not enough, I needed something which could perform only the Test for the file that I had changed: &lt;a href='https://github.com/Maher4Ever/guard-phpunit'&gt;guard-phpunit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In the PHP world, &lt;a href='https://github.com/guard/guard'&gt;Guard&lt;/a&gt; is not so popular but instead would require much more importance.&lt;/p&gt;

&lt;h2 id='install_guardphpunit'&gt;&lt;strong&gt;Install&lt;/strong&gt; &lt;a href='https://github.com/Maher4Ever/guard-phpunit'&gt;guard-phpunit&lt;/a&gt;!&lt;/h2&gt;

&lt;p&gt;Simply follow the instructions of the README.md https://github.com/Maher4Ever/guard-phpunit&lt;/p&gt;

&lt;h3 id='1_install_guardphpunit'&gt;1 Install guard-phpunit&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;gem install guard-phpunit&lt;/code&gt;&lt;/p&gt;

&lt;h3 id='2_step_create_a_'&gt;2 Step create a &lt;code&gt;Guardfile&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;guard &amp;#39;phpunit&amp;#39;, :tests_path =&amp;gt; &amp;#39;Tests&amp;#39;, :cli =&amp;gt; &amp;#39;--colors&amp;#39; do
 # Watch tests files
 watch(%r{^.+Test\.php$})
 # Watch library files and run their tests
 watch(%r{^Object/(.+)\.php}) { |m| &amp;quot;Tests/#{m[1]}Test.php&amp;quot; }
end&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='3_run_with_'&gt;3 Run with &lt;code&gt;guard&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;liuggio@liuggio:/var/repos/StatsDClientBundle$ guard
20:33:21 - INFO - Guard uses NotifySend to send notifications.
20:33:21 - INFO - Guard uses TerminalTitle to send notifications.
20:33:21 - INFO - Running all tests
20:33:23 - INFO - ..................
&amp;gt; [#51616B16C20E]
&amp;gt; [#51616B16C20E] Finished in 2 seconds
&amp;gt; [#51616B16C20E] 18 tests, 43 assertions
20:33:23 - INFO - Guard is now watching at &amp;#39;/var/www/StatsDClientBundle&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will test the entire library for you, any changes will test only the files that have changed&lt;/p&gt;

&lt;p&gt;If you install &lt;code&gt;libnotify&lt;/code&gt; with&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gem install libnotify&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;you will have an Icon next your top panel&lt;/p&gt;

&lt;p&gt;&lt;img alt='liuggio-guard-phpunit-sf2-notifier' src='http://welcometothebundle.com/assets/themes/readable-liuggio/img/guard-phpunit-sf2.png' /&gt;&lt;/p&gt;

&lt;h3 id='4_trick_guard_on_large_directories'&gt;4 Trick Guard on large directories&lt;/h3&gt;

&lt;p&gt;If you have big project you need to increase the amount of watches of libnotify&lt;/p&gt;

&lt;p&gt;see this page for more info: https://github.com/guard/listen/wiki/Increasing-the-amount-of-inotify-watchers&lt;/p&gt;

&lt;h2 id='_guard'&gt;&lt;code&gt;Inspect&lt;/code&gt; Guard!&lt;/h2&gt;

&lt;p&gt;Another plugin that I suggest is Guard for code inspection:&lt;/p&gt;

&lt;p&gt;is easy to install&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo pear install PHP_CodeSniffer
sudo gem install guard-phpcs&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then add to your Guardfile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guard &amp;#39;phpunit&amp;#39;, :tests_path =&amp;gt; &amp;#39;Tests&amp;#39;, :cli =&amp;gt; &amp;#39;--colors&amp;#39; do
 # Watch tests files
 watch(%r{^.+Test\.php$})
 # Watch library files and run their tests
 watch(%r{^/(.+)/(.+)/(.+)\.php}) { |m| &amp;quot;Test/#{m[1]}/#{m[2]}/#{m[3]}Test.php&amp;quot; }
end
guard &amp;#39;phpcs&amp;#39;, :standard =&amp;gt; &amp;#39;PSR1&amp;#39; do
    watch(%r{.*\.php$})
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will detect all the camel case problems, and you will have to follow the standard PSR1 :D&lt;/p&gt;

&lt;h2 id='guard____guardphpunitsf2'&gt;Guard + &lt;code&gt;Symfony2&lt;/code&gt; = &lt;a href='https://github.com/liuggio/guard-phpunit-sf2'&gt;guard-phpunit-sf2&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Unfortunately &lt;code&gt;guard-phpunit&lt;/code&gt; does not work with symfony2 framework,&lt;/p&gt;

&lt;p&gt;so I forked that repo and I made &lt;a href='https://github.com/liuggio/guard-phpunit-sf2'&gt;guard-phpunit-sf2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hurray!!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;guard-phpunit-sf2 has not been pushed on RubyGems. If you want to try it, clone the repository, build the gem and install it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git@github.com:liuggio/guard-phpunit-sf2.git
cd guard-phpunit-sf2
gem build guard-phpunit-sf2.gemspec
sudo gem instal guard-phpunit-sf2-0.1.4.gem&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then create the Guardfile into the root of your Symfony2 project&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guard &amp;#39;phpunit&amp;#39;, :cli =&amp;gt; &amp;#39;--colors -c app/&amp;#39; do
     # Watch tests files
     watch(%r{^src\/.+Test\.php$})

     # Watch src file and run its test,
     # Test string: src/Tvision/Bundle/CartBundle/Repository/CartRepository.php
     watch(%r{^src\/(.+)\/(.+)Bundle\/(.+)\.php$}) { |m| &amp;quot;src/#{m[1]}/#{m[2]}Bundle/Tests/#{m[3]}Test.php&amp;quot; } # Watch all files in your bundles and run the respective tests on change
end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then lunch &lt;code&gt;guard&lt;/code&gt; and start testing.&lt;/p&gt;

&lt;p&gt;PS: maybe you should uninstall guard-phpunit in order to work with symfony2 :|&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo gem uninstall guard-phpunit&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Happy test to everybody.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>ServerGrove StastdClientBundle Interesting Symfony Bundles</title>
   <link href="http://welcometothebundle.com/servergrove-stastdclientbundle-interesting-symfony-bundles"/>
   <updated>2012-11-01T06:01:25+01:00</updated>
   <id>http://welcometothebundle.com/servergrove-stastdclientbundle-interesting-symfony-bundles</id>
   <content type="html">&lt;p&gt;I was contacted by &lt;a href='https://twitter.com/_leopro_'&gt;leopro&lt;/a&gt; &lt;img alt='leopro' src='https://en.gravatar.com/avatar/26d90e88b1eb694cc1276b9ab8d7630f?s=30' /&gt; who congratulated me for the excellent results obtained with the &lt;a href='https://github.com/liuggio/StatsDClientBundle'&gt;StatsDClientBundle&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks to this comment I now know that &lt;a href='http://blog.servergrove.com/2012/10/09/interesting-symfony-bundles-statsdclientbundle/'&gt;ServerGrove&lt;/a&gt; chosen &lt;a href='https://github.com/liuggio/StatsDClientBundle'&gt;StatsD Client Bundle&lt;/a&gt; as its top choice for Symfony2 project among more than 1600.&lt;/p&gt;

&lt;p&gt;cite&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;There are well over 1600 public bundles at knpbundles.com, so sometimes really interesting and good bundles are hard time find. So we will revive the old series but this time we will do it with bundles.
In our first installment of the series we will present StatsDClientBundle written by Giulio De Donato. `&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anyone who follows a conference in europe about web developing or PHP knows &lt;a href='http://blog.servergrove.com/2012/10/09/interesting-symfony-bundles-statsdclientbundle/'&gt;ServerGrove&lt;/a&gt;, I thank them.&lt;/p&gt;

&lt;p&gt;&lt;a href='http://blog.servergrove.com/2012/10/09/interesting-symfony-bundles-statsdclientbundle/'&gt;continue reading Interesting Symfony Bundles: StatsDClientBundle on ServerGrove&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Improving the performance of a Symfony2 web application.</title>
   <link href="http://welcometothebundle.com/symfony-day-5-october-turin-2012"/>
   <updated>2012-10-31T23:01:25+01:00</updated>
   <id>http://welcometothebundle.com/symfony-day-5-october-turin-2012</id>
   <content type="html">&lt;p&gt;On October 5th, I was the speaker at the symfony day, and I was lucky enough to be able to close the conference.&lt;/p&gt;

&lt;p&gt;It was a very interesting experience, although excited I talked about what I know best: &lt;strong&gt;improving the performance of a web application&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.slideshare.net/liuggio/rationally-boost-your-symfony2-application-with-caching-tips-and-monitoring'&gt;liuggio/rationally-boost-your-symfony2-application-with-caching-tips-and-monitoring&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[edit] Two months after the talk, visitors pass the 1,200 visits (December 2012).&lt;/p&gt;

&lt;p&gt;There were a lot of other interesting topics:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Symfony2 Security Layer&lt;/strong&gt; - by @K3A, explained in detail the most difficult part of the symfony documentation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PHPUnit raised by Symfony2&lt;/strong&gt; of @euxpom, showed how many utensils you have for free by the Symfony2 framework&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Symfony CMF&lt;/strong&gt; of @jacoporomei described with an overwhelming sympathy a subject very dear to me the CMF and his architecture.&lt;/p&gt;

&lt;p&gt;See you next year &lt;a href='http://www.symfonyday.it'&gt;symfonyday.it&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;a special thanks @cirpo&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>2013-Software Team Manifesto</title>
   <link href="http://welcometothebundle.com/tvision-team-manifesto"/>
   <updated>2012-09-16T16:09:12+02:00</updated>
   <id>http://welcometothebundle.com/tvision-team-manifesto</id>
   <content type="html">&lt;h2 id='abstract'&gt;Abstract&lt;/h2&gt;

&lt;p&gt;In the chaos of the implicit, a programmer who joins a team must have a common language and some rules in order to have an integration without friction.&lt;/p&gt;

&lt;p&gt;There is a level 0, a common and accepted (or imposed by the architect) knowledge.&lt;/p&gt;

&lt;p&gt;This document defines the concepts and guidelines to follow in order to be a developer who can work in a software team in 2013.&lt;/p&gt;

&lt;p&gt;I think that you are already proficient with this notions.&lt;/p&gt;

&lt;p&gt;We use PHP as language and Symofony2 as framework.&lt;/p&gt;
&lt;script src='https://gist.github.com/4339207.js'&gt; &lt;/script&gt;
&lt;p&gt;Any comment or help is really appreciated,&lt;/p&gt;

&lt;p&gt;please help me to improve this document forking this &lt;a href='https://gist.github.com/4339207'&gt;gist&lt;/a&gt;.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Easily install statsd and graphite with vagrant</title>
   <link href="http://welcometothebundle.com/easily-install-statsd-and-graphite-with-vagrant"/>
   <updated>2012-07-31T00:00:00+02:00</updated>
   <id>http://welcometothebundle.com/easily-install-statsd-and-graphite-with-vagrant</id>
   <content type="html">&lt;p&gt;If Engineering at Tvision has a religion, it’s the Church of Graphs. If it moves, we track it.&lt;/p&gt;

&lt;p&gt;Ops I already heard this sentence, please read carefully this blog post &lt;a href='http://codeascraft.etsy.com/2011/02/15/measure-anything-measure-everything/'&gt;measure-anything-measure-everything&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For your production env sure you need statsd, you do will want to use it.&lt;/p&gt;

&lt;p&gt;If your salary is paid by a website, you need to &lt;strong&gt;monitor and react&lt;/strong&gt;, you need a monitor that pushes the informations.&lt;/p&gt;

&lt;h2 id='install_statsd__graphite__carbon__whisper__linuxos__apache__python__django__mod_wsgi_'&gt;Install Statsd + Graphite + Carbon + Whisper + LinuxOS + apache + python + django + mod_wsgi &amp;#8230;&lt;/h2&gt;

&lt;p&gt;The first time I spent 3 hours installing Graphite, now with vagrant you could try Statsd+Graphite in few minutes.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Install vagrant&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gem install vagrant&lt;/code&gt; (if you need see the official documentation)&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Installing the world with &lt;a href='http://vagrantup.com/'&gt;vagrant&lt;/a&gt; is so easy&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone https://github.com/liuggio/vagrant-statsd-graphite-puppet.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cd vagrant-statsd-graphite-puppet.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vagrant up&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;My repo is just a fork of &lt;code&gt;Jimdo/vagrant-statsd-graphite-puppet&lt;/code&gt; with a small bug fix&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;Say &amp;#8216;WOOOW&amp;#8217; then connect to&lt;/p&gt;

&lt;p&gt;graphite: http://localhost:8080/&lt;/p&gt;

&lt;p&gt;statsd: 8125:udp&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Everything is done, your virtual box with StatsD is ready to use, if you are a developer and you like web application YOU MUST use a web framework, if you are a php developer you SHOULD use Symfony2, if you use Symfony2 you should have a look to &lt;a href='https://github.com/liuggio/StatsDClientBundle'&gt;symfony2 liuggio StatsDClientBundle&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Symfony2 assets on RackSpace Cloud files</title>
   <link href="http://welcometothebundle.com/symfony2-assets-on-rackspace-cloud-files"/>
   <updated>2012-05-06T00:00:00+02:00</updated>
   <id>http://welcometothebundle.com/symfony2-assets-on-rackspace-cloud-files</id>
   <content type="html">&lt;p&gt;How to use assetic on rackspace with symfony2?&lt;/p&gt;

&lt;p&gt;The problem is how to move the static files to the cloud files and get them from twig?&lt;/p&gt;

&lt;p&gt;Following some tips from the forum &lt;a href='http://groups.google.com/group/symfony2/browse_thread/thread/8e14c145683981d4'&gt;Registering (s3) stream wrapper for AsseticBundle – Symfony2 | Google Gruppi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I created this bundle &lt;a href='https://github.com/liuggio/RackspaceCloudFilesBundle'&gt;RackspaceCloudFilesBundle&lt;/a&gt; that handles the static files easily&lt;/p&gt;

&lt;h2 id='installing'&gt;Installing&lt;/h2&gt;

&lt;h3 id='step_1'&gt;Step 1&lt;/h3&gt;

&lt;p&gt;follow the README into the &lt;a href='https://github.com/liuggio/RackspaceCloudFilesBundle
'&gt;RackspaceCloudFilesBundle&lt;/a&gt;&lt;/p&gt;

&lt;h3 id='step_2'&gt;Step 2&lt;/h3&gt;

&lt;p&gt;modify the app/config/config.yml and the app/parameters.ini&lt;/p&gt;
&lt;script src='https://gist.github.com/2420800.js'&gt; &lt;/script&gt;
&lt;h3 id='step_3'&gt;Step 3&lt;/h3&gt;

&lt;p&gt;when you will deploy a new image just run app/console assetic:dump –env=prod&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;That’s it!!!!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PLEASE FELL FREE TO CLONE AND SEND PULL REQUEST!&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Using Github or Bitbucket as Assets container for Symfony2</title>
   <link href="http://welcometothebundle.com/using-github-or-bitbucket-as-assets-container-for-symfony2"/>
   <updated>2012-04-20T00:00:00+02:00</updated>
   <id>http://welcometothebundle.com/using-github-or-bitbucket-as-assets-container-for-symfony2</id>
   <content type="html">&lt;p&gt;I made the following changes to the config, deps and autoload in order to push all the assets directly into a github repository.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Why you should pay for CDN if you can use Github?&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id='theory'&gt;Theory&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;Php library&lt;/span&gt; the library teqneers/PHP-Stream-Wrapper-for-Git registers a stream and commit to a repository each file that is moved throw the stream&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;span&gt;Symfony2&lt;/span&gt; Assetic bundle compresses and streams the files in your local repository, and twig render the raw.github url&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;&lt;span&gt;Git-Hook&lt;/span&gt; The Post-Commit hook will push to remote repository automatically&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='how_to'&gt;How To&lt;/h2&gt;

&lt;p&gt;Just 3 steps&lt;/p&gt;

&lt;h2 id='step_1_install_the_library_in_your_symfony2'&gt;Step 1 Install the library in your symfony2&lt;/h2&gt;

&lt;p&gt;In your deps file add the following lines, and then run bin/vendors install&lt;/p&gt;
&lt;script src='https://gist.github.com/2427058.js?file=deps'&gt; &lt;/script&gt;
&lt;p&gt;Register namespace and register stream into &lt;code&gt;app/autoload.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;‘/usr/bin/git’ is where your git binary are&lt;/p&gt;

&lt;p&gt;‘php-git’ is the name of the stream&lt;/p&gt;
&lt;script src='https://gist.github.com/2427058.js?file=app-autoload.php'&gt; &lt;/script&gt;
&lt;h2 id='step_2_github_or_bitbucket_repository'&gt;Step 2 Github or BitBucket Repository&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Create Repo in the root /UsingGitHubAsAssetsCloudFiles&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href='http://help.github.com/create-a-repo/'&gt;http://help.github.com/create-a-repo/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;the public url of the repo will be www.github.com/liuggio/UsingGitHubAsAssetsCloudFiles,&lt;/p&gt;

&lt;p&gt;your remote name is ‘origin’ and the branch is ‘master’&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Add the Hook into the /UsingGitHubAsAssetsCloudFiles&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;create a file into ‘/UsingGitHubAsAssetsCloudFiles/.git/hooks/post-commit’&lt;/p&gt;
&lt;script src='https://gist.github.com/2427058.js?file=UsingGitHubAsAssetsCloudFiles-.git-hooks-post-commit'&gt; &lt;/script&gt;
&lt;h2 id='step_3_configyml_and_assets'&gt;Step 3 Config.yml and Assets&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;modify your &lt;code&gt;app/config/config.yml&lt;/code&gt; in 2 different places&lt;/li&gt;
&lt;/ul&gt;
&lt;script src='https://gist.github.com/2427058.js?file=app-config-config.yml'&gt; &lt;/script&gt;
&lt;ul&gt;
&lt;li&gt;dump all the file for prod&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;app/console assetic:dump –env=prod&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;go to your symfony2 website http://yoursymfony2.com/web/app.php/hello/{YES}&lt;/p&gt;

&lt;p&gt;THAT’S ALL.&lt;/p&gt;

&lt;p&gt;Now github is hosting your assets (for free) and your web server is happy (and if your webserver is into the cloud you’ll not charged for assets )&lt;/p&gt;</content>
 </entry>
 
 
</feed>